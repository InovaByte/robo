<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bot de Trading Binance Futures - Estrat√©gia de Seguimento de Tend√™ncia</title>
<style>
body {
  font-size: 16px;
  padding: 1rem;
  font-family: Arial, sans-serif;
  background-color: #f0f2f5;
  margin: 0;
  color: #333;
}
.container {
  max-width: 100%;
  margin: 0 auto;
  background-color: #fff;
  border-radius: 8px;
  padding: 1rem;
  box-shadow: 0 0 10px rgba(0,0,0,0.1);
}
h1 {
  color: #f0b90b;
  text-align: center;
  font-size: 1.5rem;
}
.controls {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
}
button {
  background-color: #f0b90b;
  border: none;
  color: white;
  padding: 0.5rem 1rem;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 1rem;
  margin: 4px 2px;
  cursor: pointer;
  border-radius: 4px;
}
.stats {
  display: flex;
  justify-content: space-between;
  background-color: #f8f9fa;
  padding: 10px;
  border-radius: 4px;
  margin-bottom: 20px;
}
.stat {
  text-align: center;
}
.stat-value {
  font-size: 1.2rem;
  font-weight: bold;
  color: #f0b90b;
}
#log {
  margin-top: 20px;
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 10px;
  font-family: monospace;
}
#signals {
  margin-top: 20px;
  border: 1px solid #ddd;
  padding: 10px;
  border-radius: 4px;
  max-height: 200px;
  overflow-y: auto;
}
.signal {
  margin-bottom: 10px;
  padding: 10px;
  border-radius: 4px;
}
.signal.buy {
  background-color: #d4edda;
  color: #155724;
}
.signal.sell {
  background-color: #f8d7da;
  color: #721c24;
}
#tradingview-widget-container {
  position: relative;
  height: 60vh !important;
  margin-bottom: 20px;
}
#tradingview-widget-container > div {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
#symbolSelector {
  width: 100%;
  padding: 10px;
  margin-bottom: 20px;
  font-size: 16px;
}
@media (min-width: 768px) {
  .container {
    max-width: 1200px;
    padding: 2rem;
  }
  
  h1 {
    font-size: 2rem;
  }
  
  .controls {
    flex-direction: row;
  }
  
  button {
    width: auto;
  }
  
  .stats {
    flex-direction: row;
  }
  
  .stat {
    margin-bottom: 0;
  }
  
  #tradingview-widget-container {
    height: 400px !important;
  }
}
@media (min-width: 1024px) {
  .container {
    padding: 2.5rem;
  }
  
  h1 {
    font-size: 2.5rem;
  }
  
  #tradingview-widget-container {
    height: 500px !important;
  }
}
body.dark-mode {
  background-color: #1a1a1a;
  color: #ffffff;
}
body.dark-mode .container {
  background-color: #2a2a2a;
}
body.dark-mode button {
  background-color: #3a3a3a;
  color: #ffffff;
}
body.dark-mode .stats {
  background-color: #3a3a3a;
}
body.dark-mode .stat-value {
  color: #f0b90b;
}
body.dark-mode #log,
body.dark-mode #signals {
  border-color: #4a4a4a;
}
body.dark-mode .signal.buy {
  background-color: #1e3a2b;
  color: #4caf50;
}
body.dark-mode .signal.sell {
  background-color: #3a1e1e;
  color: #f44336;
}
footer {
  margin-top: 20px;
  padding: 10px;
  background-color: #f0f2f5;
  text-align: center;
  font-size: 0.9rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
body.dark-mode footer {
  background-color: #2a2a2a;
  color: #ffffff;
}
.language-toggle {
  background-color: transparent;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background-color 0.3s;
}
.language-toggle:hover {
  background-color: #e0e0e0;
}
body.dark-mode .language-toggle {
  border-color: #555;
  color: #ffffff;
}
body.dark-mode .language-toggle:hover {
  background-color: #3a3a3a;
}
</style>
</head>
<body>
  <div class="container">
    <h1>Bot de Trading Binance Futures - Estrat√©gia de Seguimento de Tend√™ncia</h1>
    <select id="symbolSelector"></select>
    <div class="controls">
      <button id="startBtn">Iniciar Bot</button>
      <button id="stopBtn">Parar Bot</button>
      <button id="themeToggleBtn">Toggle Dark Mode</button>
    </div>
    <div id="tradingview-widget-container"></div>
    <div class="stats">
      <div class="stat">
        <div>Sinais Gerados</div>
        <div id="signalsCount" class="stat-value">0</div>
      </div>
      <div class="stat">
        <div>√öltimo Pre√ßo</div>
        <div id="lastPrice" class="stat-value">0 USDT</div>
      </div>
      <div class="stat">
        <div>Posi√ß√µes Abertas</div>
        <div id="openPositions" class="stat-value">0</div>
      </div>
    </div>
    <div id="signals"></div>
    <div id="log"></div>
  </div>
  <footer>
    <p>&copy; 2023 Jean Vieira. All rights reserved.</p>
    <button id="languageToggle" class="language-toggle">üåê PT</button>
  </footer>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
<script src="https://s3.tradingview.com/tv.js"></script>
<script>
let symbol = 'BTCUSDT';
const interval = '15m';
let leverage = 20;
let positions = [];
let lastSignalTime = 0;
const signalCooldown = 15 * 60 * 1000; // 15 minutes in milliseconds

let isRunning = false;
let ws;
let signalsCount = 0;
let prices = [];
let volumes = [];
let ema50 = [];
let ema200 = [];
let rsiValues = [];
let widget;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;
const baseReconnectDelay = 1000;

// Initialize Firebase
const firebaseConfig = {
  apiKey: "AIzaSyAxDf9rZvv9qi-uooo9RXqTJojldocF1Vo",
  authDomain: "bot-trading-99f76.firebaseapp.com",
  projectId: "bot-trading-99f76",
  storageBucket: "bot-trading-99f76.appspot.com",
  messagingSenderId: "820777140022",
  appId: "1:820777140022:web:85d5e9114bb8e4d4c93d97",
  measurementId: "G-XS0JKX9TR7"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

function saveDataToFirebase() {
  db.collection("tradingData").doc("currentState").set({
    prices: prices,
    volumes: volumes,
    ema50: ema50,
    ema200: ema200,
    rsiValues: rsiValues,
    positions: positions,
    signalsCount: signalsCount,
    lastSignalTime: lastSignalTime
  })
  .then(() => console.log("Data saved to Firebase"))
  .catch((error) => console.error("Error saving data: ", error));
}

function loadDataFromFirebase() {
  db.collection("tradingData").doc("currentState").get()
    .then((doc) => {
      if (doc.exists) {
        const data = doc.data();
        prices = data.prices;
        volumes = data.volumes;
        ema50 = data.ema50;
        ema200 = data.ema200;
        rsiValues = data.rsiValues;
        positions = data.positions;
        signalsCount = data.signalsCount;
        lastSignalTime = data.lastSignalTime;
        
        // Update UI with loaded data
        document.getElementById('signalsCount').textContent = signalsCount;
        document.getElementById('lastPrice').textContent = `${prices[prices.length - 1]} USDT`;
        document.getElementById('openPositions').textContent = positions.length;
        
        console.log("Data loaded from Firebase");
      } else {
        console.log("No data found in Firebase");
      }
    })
    .catch((error) => console.error("Error loading data: ", error));
}

document.addEventListener('DOMContentLoaded', loadDataFromFirebase);

async function fetchBinanceSymbols() {
  try {
    const response = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    return data.symbols.map(symbol => symbol.symbol);
  } catch (error) {
    console.error('Error fetching Binance symbols:', error);
    logMessage(`Erro ao buscar s√≠mbolos da Binance: ${error.message}`);
    return [];
  }
}

function populateSymbolSelector(symbols) {
  const selector = document.getElementById('symbolSelector');
  selector.innerHTML = '';
  symbols.forEach(symbol => {
    const option = document.createElement('option');
    option.value = symbol;
    option.textContent = symbol;
    selector.appendChild(option);
  });
  selector.value = 'BTCUSDT'; // Set default value
}

function updateSymbol(newSymbol) {
  symbol = newSymbol;
  if (widget) {
    widget.setSymbol(`BINANCE:${newSymbol}`);
  }
  resetBot();
  if (isRunning) {
    runBot();
  }
}

function calculateEMA(data, period) {
  const k = 2 / (period + 1);
  let ema = data[0];
  return data.map((price, i) => {
    if (i === 0) return ema;
    return (price * k) + (ema * (1 - k));
  });
}

function logMessage(message) {
  console.log(message);
  const logElement = document.getElementById('log');
  const logEntry = document.createElement('div');
  logEntry.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
  logElement.appendChild(logEntry);
  logElement.scrollTop = logElement.scrollHeight;
}

function displaySignal(signal, price) {
  signalsCount++;
  document.getElementById('signalsCount').textContent = signalsCount;

  const signalsContainer = document.getElementById('signals');
  const signalElement = document.createElement('div');
  signalElement.className = `signal ${signal}`;
  
  const lastRSI = rsiValues[rsiValues.length - 1].toFixed(2);
  const lastSMA50 = calculateSMA(prices, 50)[prices.length - 1].toFixed(2);
  const lastSMA200 = calculateSMA(prices, 200)[prices.length - 1].toFixed(2);
  const { macdLine, signalLine } = calculateMACD(prices);
  const lastMACD = macdLine[macdLine.length - 1].toFixed(2);
  const lastSignalLine = signalLine[signalLine.length - 1].toFixed(2);

  signalElement.innerHTML = `
    <strong>${signal.toUpperCase()} signal at ${price} USDT</strong><br>
    RSI: ${lastRSI}<br>
    SMA50: ${lastSMA50}<br>
    SMA200: ${lastSMA200}<br>
    MACD: ${lastMACD}<br>
    Signal Line: ${lastSignalLine}
  `;
  
  signalsContainer.insertBefore(signalElement, signalsContainer.firstChild);

  if (signalsContainer.children.length > 10) {
    signalsContainer.removeChild(signalsContainer.lastChild);
  }
  
  saveDataToFirebase();
}

function generateSignal() {
  if (prices.length < 200) {
    return null;
  }

  const lastPrice = prices[prices.length - 1];
  const sma50 = calculateSMA(prices, 50);
  const sma200 = calculateSMA(prices, 200);
  const rsi = calculateRSI(prices, 14);
  const { macdLine, signalLine } = calculateMACD(prices);
  const bollingerBands = calculateBollingerBands(prices);

  const lastSMA50 = sma50[sma50.length - 1];
  const lastSMA200 = sma200[sma200.length - 1];
  const lastRSI = rsi[rsi.length - 1];
  const lastMACD = macdLine[macdLine.length - 1];
  const lastSignal = signalLine[signalLine.length - 1];
  const lastUpperBB = bollingerBands.upper[bollingerBands.upper.length - 1];
  const lastLowerBB = bollingerBands.lower[bollingerBands.lower.length - 1];
  const lastMiddleBB = bollingerBands.middle[bollingerBands.middle.length - 1];

  const currentTime = Date.now();
  if (currentTime - lastSignalTime < signalCooldown) {
    return null;
  }

  const isBuySignal = 
    lastSMA50 > lastSMA200 &&
    lastRSI > 40 && lastRSI < 60 &&
    lastMACD > lastSignal &&
    lastPrice > lastMiddleBB &&
    prices.slice(-5).every(price => price > lastSMA50);

  const isSellSignal = 
    lastSMA50 < lastSMA200 &&
    lastRSI > 60 &&
    lastMACD < lastSignal &&
    lastPrice < lastMiddleBB &&
    prices.slice(-5).every(price => price < lastSMA50);

  if (isBuySignal) {
    lastSignalTime = currentTime;
    return 'buy';
  } else if (isSellSignal) {
    lastSignalTime = currentTime;
    return 'sell';
  }

  return null;
}

function openPosition(type, entryPrice) {
  const currentTime = Date.now();
  if (currentTime - lastSignalTime < signalCooldown) {
    logMessage(`Signal ignored due to cooldown period`);
    return;
  }

  const conflictingPosition = positions.find(p => p.type !== type);
  if (conflictingPosition) {
    logMessage(`Cannot open ${type} position. Conflicting ${conflictingPosition.type} position exists.`);
    return;
  }

  const riskPercentage = 0.02;
  const accountBalance = 10000;
  const riskAmount = accountBalance * riskPercentage;
  const stopLossPercentage = 0.02;
  const takeProfitRatio = 2;

  const stopLossPrice = type === 'buy' 
    ? entryPrice * (1 - stopLossPercentage) 
    : entryPrice * (1 + stopLossPercentage);
  
  const takeProfitPrice = type === 'buy'
    ? entryPrice * (1 + (stopLossPercentage * takeProfitRatio))
    : entryPrice * (1 - (stopLossPercentage * takeProfitRatio));

  const position = {
    type,
    entryPrice,
    stopLossPrice,
    takeProfitPrice,
    trailingStopDistance: entryPrice * 0.015,
    quantity: riskAmount / Math.abs(entryPrice - stopLossPrice)
  };

  positions.push(position);
  logMessage(`Opened ${type} position: Entry: ${entryPrice}, SL: ${stopLossPrice}, TP: ${takeProfitPrice}`);

  lastSignalTime = currentTime;
  saveDataToFirebase();
}

function normalWebSocketHandler(event) {
  const data = JSON.parse(event.data);
  if (data.k) {
    const candle = data.k;
    const closePrice = parseFloat(candle.c);
    
    prices.push(closePrice);
    volumes.push(parseFloat(candle.v));
    
    if (prices.length > 200) {
      prices.shift();
      volumes.shift();
    }
    
    ema50 = calculateEMA(prices, 50);
    ema200 = calculateEMA(prices, 200);
    rsiValues = calculateRSI(prices);
    
    document.getElementById('lastPrice').textContent = `${closePrice} USDT`;
    
    const signal = generateSignal();
    if (signal) {
      displaySignal(signal, closePrice);
      openPosition(signal, closePrice);
    }
    
    updatePositions(closePrice);
    document.getElementById('openPositions').textContent = positions.length;
    saveDataToFirebase();
  }
}

document.addEventListener('DOMContentLoaded', async function() {
  try {
    const symbols = await fetchBinanceSymbols();
    populateSymbolSelector(symbols);

    document.getElementById('startBtn').addEventListener('click', () => {
      if (!isRunning) {
        isRunning = true;
        logMessage('Iniciando bot...');
        runBot();
      }
    });

    document.getElementById('stopBtn').addEventListener('click', () => {
      if (isRunning) {
        isRunning = false;
        if (ws) ws.close();
        logMessage('Parando bot...');
      }
    });

    document.getElementById('symbolSelector').addEventListener('change', (event) => {
      const newSymbol = event.target.value;
      updateSymbol(newSymbol);
    });

    initTradingViewWidget(symbol);
  } catch (error) {
    console.error('Error during initialization:', error);
    logMessage(`Erro durante a inicializa√ß√£o: ${error.message}`);
  }
});

const translations = {
  'pt': {
    'title': 'Bot de Trading Binance Futures - Estrat√©gia de Seguimento de Tend√™ncia',
    'startBtn': 'Iniciar Bot',
    'stopBtn': 'Parar Bot',
    'themeToggleBtn': 'Alternar Modo Escuro',
    'signalsGenerated': 'Sinais Gerados',
    'lastPrice': '√öltimo Pre√ßo',
    'openPositions': 'Posi√ß√µes Abertas',
    'footer': '¬© 2023 Jean Vieira. Todos os direitos reservados.'
  },
  'en': {
    'title': 'Binance Futures Trading Bot - Trend Following Strategy',
    'startBtn': 'Start Bot',
    'stopBtn': 'Stop Bot',
    'themeToggleBtn': 'Toggle Dark Mode',
    'signalsGenerated': 'Signals Generated',
    'lastPrice': 'Last Price',
    'openPositions': 'Open Positions',
    'footer': '¬© 2023 Jean Vieira. All rights reserved.'
  },
  'es': {
    'title': 'Bot de Trading Binance Futures - Estrategia de Seguimiento de Tendencia',
    'startBtn': 'Iniciar Bot',
    'stopBtn': 'Detener Bot',
    'themeToggleBtn': 'Cambiar Modo Oscuro',
    'signalsGenerated': 'Se√±ales Generadas',
    'lastPrice': '√öltimo Precio',
    'openPositions': 'Posiciones Abiertas',
    'footer': '¬© 2023 Jean Vieira. Todos los derechos reservados.'
  }
};

let currentLanguage = 'pt';

function changeLanguage(lang) {
  currentLanguage = lang;
  document.querySelector('h1').textContent = translations[lang].title;
  document.getElementById('startBtn').textContent = translations[lang].startBtn;
  document.getElementById('stopBtn').textContent = translations[lang].stopBtn;
  document.getElementById('themeToggleBtn').textContent = translations[lang].themeToggleBtn;
  document.querySelector('.stat:nth-child(1) div:first-child').textContent = translations[lang].signalsGenerated;
  document.querySelector('.stat:nth-child(2) div:first-child').textContent = translations[lang].lastPrice;
  document.querySelector('.stat:nth-child(3) div:first-child').textContent = translations[lang].openPositions;
  document.querySelector('footer p').textContent = translations[lang].footer;
  document.getElementById('languageToggle').textContent = `üåê ${lang.toUpperCase()}`;
}

document.getElementById('languageToggle').addEventListener('click', () => {
  const langs = ['pt', 'en', 'es'];
  const currentIndex = langs.indexOf(currentLanguage);
  const nextIndex = (currentIndex + 1) % langs.length;
  changeLanguage(langs[nextIndex]);
});

// Call this function at the end of the DOMContentLoaded event listener
changeLanguage('pt');

function resetBot() {
  if (ws) {
    ws.close();
  }
  prices = [];
  volumes = [];
  ema50 = [];
  ema200 = [];
  rsiValues = [];
  positions = [];
  signalsCount = 0;
  reconnectAttempts = 0;
  document.getElementById('signalsCount').textContent = '0';
  document.getElementById('lastPrice').textContent = '0 USDT';
  document.getElementById('openPositions').textContent = '0';
  document.getElementById('signals').innerHTML = '';
  document.getElementById('log').innerHTML = '';
}

function calculateSMA(data, period) {
  return data.map((_, index, array) => 
    array.slice(Math.max(0, index - period + 1), index + 1)
      .reduce((sum, value) => sum + value, 0) / period
  );
}

function calculateMACD(data, shortPeriod = 12, longPeriod = 26, signalPeriod = 9) {
  const shortEMA = calculateEMA(data, shortPeriod);
  const longEMA = calculateEMA(data, longPeriod);
  const macdLine = shortEMA.map((short, i) => short - longEMA[i]);
  const signalLine = calculateEMA(macdLine, signalPeriod);
  return { macdLine, signalLine };
}

function calculateBollingerBands(data, period = 20, stdDev = 2) {
  const sma = calculateSMA(data, period);
  const stdDevs = data.map((_, index, array) => {
    const slice = array.slice(Math.max(0, index - period + 1), index + 1);
    const mean = sma[index];
    const squaredDiffs = slice.map(value => Math.pow(value - mean, 2));
    const variance = squaredDiffs.reduce((sum, value) => sum + value, 0) / period;
    return Math.sqrt(variance);
  });
  
  const upperBand = sma.map((value, index) => value + (stdDev * stdDevs[index]));
  const lowerBand = sma.map((value, index) => value - (stdDev * stdDevs[index]));
  
  return { middle: sma, upper: upperBand, lower: lowerBand };
}

function calculateRSI(prices, period = 14) {
  if (prices.length < period + 1) {
    return null;
  }

  let gains = 0;
  let losses = 0;

  for (let i = 1; i <= period; i++) {
    const difference = prices[i] - prices[i - 1];
    if (difference >= 0) {
      gains += difference;
    } else {
      losses -= difference;
    }
  }

  let averageGain = gains / period;
  let averageLoss = losses / period;

  const rsiValues = [100 - (100 / (1 + averageGain / averageLoss))];

  for (let i = period + 1; i < prices.length; i++) {
    const difference = prices[i] - prices[i - 1];
    let currentGain = 0;
    let currentLoss = 0;

    if (difference >= 0) {
      currentGain = difference;
    } else {
      currentLoss = -difference;
    }

    averageGain = (averageGain * (period - 1) + currentGain) / period;
    averageLoss = (averageLoss * (period - 1) + currentLoss) / period;

    rsiValues.push(100 - (100 / (1 + averageGain / averageLoss)));
  }

  return rsiValues;
}

function updatePositions(currentPrice) {
  positions = positions.filter(position => {
    if (position.type === 'buy') {
      if (currentPrice <= position.stopLossPrice) {
        logMessage(`Stop loss triggered for buy position. Entry: ${position.entryPrice}, Exit: ${position.stopLossPrice}`);
        return false;
      }
      if (currentPrice >= position.takeProfitPrice) {
        logMessage(`Take profit triggered for buy position. Entry: ${position.entryPrice}, Exit: ${position.takeProfitPrice}`);
        return false;
      }
      const newTrailingStop = currentPrice - position.trailingStopDistance;
      if (newTrailingStop > position.stopLossPrice) {
        position.stopLossPrice = newTrailingStop;
      }
    } else if (position.type === 'sell') {
      if (currentPrice >= position.stopLossPrice) {
        logMessage(`Stop loss triggered for sell position. Entry: ${position.entryPrice}, Exit: ${position.stopLossPrice}`);
        return false;
      }
      if (currentPrice <= position.takeProfitPrice) {
        logMessage(`Take profit triggered for sell position. Entry: ${position.entryPrice}, Exit: ${position.takeProfitPrice}`);
        return false;
      }
      const newTrailingStop = currentPrice + position.trailingStopDistance;
      if (newTrailingStop < position.stopLossPrice) {
        position.stopLossPrice = newTrailingStop;
      }
    }
    return true;
  });
  saveDataToFirebase();
}

function initTradingViewWidget(initialSymbol) {
  if (widget) {
    widget.remove();
  }
  
  widget = new TradingView.widget({
    "width": "100%",
    "height": "100%",
    "symbol": "BINANCE:" + initialSymbol,
    "interval": "15",
    "timezone": "Etc/UTC",
    "theme": "light",
    "style": "1",
    "locale": "br",
    "toolbar_bg": "#f1f3f6",
    "enable_publishing": false,
    "hide_side_toolbar": false,
    "allow_symbol_change": true,
    "studies": [
      "MASimple@tv-basicstudies",
      "MASimple@tv-basicstudies",
      "RSI@tv-basicstudies",
      "MACD@tv-basicstudies",
      "BB@tv-basicstudies"
    ],
    "container_id": "tradingview-widget-container",
    "studies_overrides": {
      "moving average.length": 9,
      "moving average.1.length": 21,
      "relative strength index.length": 14,
      "moving average convergence/divergence.fast length": 12,
      "moving average convergence/divergence.slow length": 26,
      "moving average convergence/divergence.signal smoothing": 9,
      "bollinger bands.length": 20,
      "bollinger bands.stddev": 2
    }
  });
}

function connectWebSocket() {
  if (ws && ws.readyState !== WebSocket.CLOSED) {
    logMessage('WebSocket is already connected or connecting. Closing existing connection.');
    ws.close();
  }
  
  const wsSymbol = symbol.toLowerCase();
  ws = new WebSocket(`wss://fstream.binance.com/ws/${wsSymbol}@kline_${interval}`);

  ws.onopen = () => {
    logMessage(`WebSocket conectado para ${symbol}`);
    reconnectAttempts = 0;
  };

  ws.onmessage = normalWebSocketHandler;

  ws.onerror = (error) => {
    console.error('WebSocket error:', error);
    logMessage(`Erro no WebSocket: ${error.message || 'Erro desconhecido'}`);
  };

  ws.onclose = (event) => {
    console.log('WebSocket closed:', event);
    logMessage(`Conex√£o WebSocket fechada. C√≥digo: ${event.code}, Raz√£o: ${event.reason || 'N√£o especificada'}`);
    
    if (isRunning && reconnectAttempts < maxReconnectAttempts) {
      const delay = Math.min(30000, baseReconnectDelay * Math.pow(2, reconnectAttempts));
      logMessage(`Tentando reconectar em ${delay / 1000} segundos...`);
      setTimeout(() => {
        reconnectAttempts++;
        connectWebSocket();
      }, delay);
    } else if (reconnectAttempts >= maxReconnectAttempts) {
      logMessage('N√∫mero m√°ximo de tentativas de reconex√£o atingido. Por favor, reinicie o bot manualmente.');
      isRunning = false;
    }
  };
}

async function runBot() {
  if (!isRunning) return;

  try {
    const historicalData = await fetchHistoricalData(symbol, interval, '6 months');
    
    prices = historicalData.prices;
    volumes = historicalData.volumes;

    ema50 = calculateEMA(prices, 50);
    ema200 = calculateEMA(prices, 200);
    rsiValues = calculateRSI(prices);

    reconnectAttempts = 0;
    connectWebSocket();

  } catch (error) {
    console.error('Error in runBot:', error);
    logMessage(`Erro ao executar o bot: ${error.message}`);
    if (error instanceof TypeError) {
      logMessage('Erro de rede. Verifique sua conex√£o com a internet.');
    }
    isRunning = false;

    setTimeout(() => {
      if (isRunning) {
        logMessage('Tentando reconectar...');
        runBot();
      }
    }, 5000);
  }
}

async function fetchHistoricalData(symbol, interval, duration) {
  const endTime = Date.now();
  const startTime = endTime - (6 * 30 * 24 * 60 * 60 * 1000);

  const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&startTime=${startTime}&endTime=${endTime}`);
  
  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }
  
  const data = await response.json();
  return {
    prices: data.map(candle => parseFloat(candle[4])),
    volumes: data.map(candle => parseFloat(candle[5]))
  };
}
</script>
</body></html>
